; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_spi_bus.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_bus.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -D__MICROLIB -D__UVISION_VERSION=525 -D_RTE_ -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX --omf_browse=.\flash\obj\bsp_spi_bus.crf ..\..\User\bsp_stm32f4xx\src\bsp_spi_bus.c]
                          THUMB

                          AREA ||i.bsp_InitSPIBus||, CODE, READONLY, ALIGN=2

                  bsp_InitSPIBus PROC
;;;40     */
;;;41     void bsp_InitSPIBus(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;42     {
;;;43     #ifdef SOFT_SPI		/* 软件SPI */
;;;44     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;45     
;;;46     	/* 打开GPIO时钟 */
;;;47     	RCC_AHB1PeriphClockCmd(RCC_SCK | RCC_MOSI | RCC_MISO, ENABLE);
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;48     
;;;49     	/* 配置几个推完输出IO */
;;;50     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00000a  2001              MOVS     r0,#1
00000c  f88d0004          STRB     r0,[sp,#4]
;;;51     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000010  2000              MOVS     r0,#0
000012  f88d0006          STRB     r0,[sp,#6]
;;;52     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
000016  f88d0007          STRB     r0,[sp,#7]
;;;53     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;	/* IO口最大速度 *///25
00001a  2001              MOVS     r0,#1
00001c  f88d0005          STRB     r0,[sp,#5]
;;;54     
;;;55     	GPIO_InitStructure.GPIO_Pin = PIN_SCK;
000020  2080              MOVS     r0,#0x80
000022  9000              STR      r0,[sp,#0]
;;;56     	GPIO_Init(PORT_SCK, &GPIO_InitStructure);
000024  4669              MOV      r1,sp
000026  480d              LDR      r0,|L1.92|
000028  f7fffffe          BL       GPIO_Init
;;;57     
;;;58     	GPIO_InitStructure.GPIO_Pin = PIN_MOSI;
00002c  2020              MOVS     r0,#0x20
00002e  9000              STR      r0,[sp,#0]
;;;59     	GPIO_Init(PORT_MOSI, &GPIO_InitStructure);
000030  4669              MOV      r1,sp
000032  480a              LDR      r0,|L1.92|
000034  f7fffffe          BL       GPIO_Init
;;;60     
;;;61     	/* 配置GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */
;;;62     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* 设为输入口 */
000038  2000              MOVS     r0,#0
00003a  f88d0004          STRB     r0,[sp,#4]
;;;63     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
00003e  f88d0006          STRB     r0,[sp,#6]
;;;64     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 无需上下拉电阻 */
000042  f88d0007          STRB     r0,[sp,#7]
;;;65     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;	/* IO口最大速度 */
000046  2001              MOVS     r0,#1
000048  f88d0005          STRB     r0,[sp,#5]
;;;66     
;;;67     	GPIO_InitStructure.GPIO_Pin = PIN_MISO;
00004c  0200              LSLS     r0,r0,#8
00004e  9000              STR      r0,[sp,#0]
;;;68     	GPIO_Init(PORT_MISO, &GPIO_InitStructure);
000050  4669              MOV      r1,sp
000052  4802              LDR      r0,|L1.92|
000054  f7fffffe          BL       GPIO_Init
;;;69     #endif
;;;70     
;;;71     #ifdef HARD_SPI
;;;72     	/* 硬件SPI */
;;;73     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;74     
;;;75     	/* 开启GPIO时钟 */
;;;76     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
;;;77     
;;;78     	/* 开启SPI时钟 */
;;;79     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
;;;80     
;;;81     	/* 配置 SCK, MISO 、 MOSI 为复用功能 */
;;;82     	//GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_SPI3);
;;;83     	//GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_SPI3);
;;;84     	//GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_SPI3);
;;;85     	/* 配置 SCK, MISO 、 MOSI 为复用功能 */
;;;86     	GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_SPI1);
;;;87     	GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_SPI1);
;;;88     	GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_SPI1);
;;;89     
;;;90     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;91     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;
;;;92     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;93     	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
;;;94     
;;;95     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
;;;96     	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;97     
;;;98     	/* 打开SPI时钟 */
;;;99     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
;;;100    
;;;101    #endif
;;;102    }
000058  bd1c              POP      {r2-r4,pc}
;;;103    
                          ENDP

00005a  0000              DCW      0x0000
                  |L1.92|
                          DCD      0x40020400

                          AREA ||i.bsp_SPI_Init||, CODE, READONLY, ALIGN=2

                  bsp_SPI_Init PROC
;;;111    */
;;;112    void bsp_SPI_Init(uint16_t _cr1)
000000  4903              LDR      r1,|L2.16|
;;;113    {
;;;114    	SPI1->CR1 = ((SPI1->CR1 & 0x3040) | _cr1);
000002  8809              LDRH     r1,[r1,#0]
000004  f4015141          AND      r1,r1,#0x3040
000008  4301              ORRS     r1,r1,r0
00000a  4a01              LDR      r2,|L2.16|
00000c  8011              STRH     r1,[r2,#0]
;;;115    }
00000e  4770              BX       lr
;;;116    
                          ENDP

                  |L2.16|
                          DCD      0x40013000

                          AREA ||i.bsp_SetSpiSck||, CODE, READONLY, ALIGN=2

                  bsp_SetSpiSck PROC
;;;388    #ifdef SOFT_SPI		/* 软件SPI */
;;;389    void bsp_SetSpiSck(uint8_t _data)
000000  b510              PUSH     {r4,lr}
;;;390    {
000002  4604              MOV      r4,r0
;;;391    	if (_data == 0)
000004  b924              CBNZ     r4,|L3.16|
;;;392    	{
;;;393    		SCK_0();
000006  2180              MOVS     r1,#0x80
000008  4804              LDR      r0,|L3.28|
00000a  f7fffffe          BL       GPIO_ResetBits
00000e  e003              B        |L3.24|
                  |L3.16|
;;;394    	}
;;;395    	else
;;;396    	{
;;;397    		SCK_1();
000010  2180              MOVS     r1,#0x80
000012  4802              LDR      r0,|L3.28|
000014  f7fffffe          BL       GPIO_SetBits
                  |L3.24|
;;;398    	}
;;;399    }
000018  bd10              POP      {r4,pc}
;;;400    #endif
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x40020400

                          AREA ||i.bsp_SpiBusBusy||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusBusy PROC
;;;374    */
;;;375    uint8_t bsp_SpiBusBusy(void)
000000  4801              LDR      r0,|L4.8|
;;;376    {
;;;377    	return g_spi_busy;
000002  7800              LDRB     r0,[r0,#0]  ; g_spi_busy
;;;378    }
000004  4770              BX       lr
;;;379    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_SpiBusEnter||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusEnter PROC
;;;348    */
;;;349    void bsp_SpiBusEnter(void)
000000  2001              MOVS     r0,#1
;;;350    {
;;;351    	g_spi_busy = 1;
000002  4901              LDR      r1,|L5.8|
000004  7008              STRB     r0,[r1,#0]
;;;352    }
000006  4770              BX       lr
;;;353    
                          ENDP

                  |L5.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_SpiBusExit||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusExit PROC
;;;361    */
;;;362    void bsp_SpiBusExit(void)
000000  2000              MOVS     r0,#0
;;;363    {
;;;364    	g_spi_busy = 0;
000002  4901              LDR      r1,|L6.8|
000004  7008              STRB     r0,[r1,#0]
;;;365    }
000006  4770              BX       lr
;;;366    
                          ENDP

                  |L6.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_spiDelay||, CODE, READONLY, ALIGN=1

                  bsp_spiDelay PROC
;;;124    */
;;;125    void bsp_spiDelay(void)
000000  2000              MOVS     r0,#0
;;;126    {
;;;127    #if 1
;;;128    	uint32_t i;
;;;129    
;;;130    	/*
;;;131    		延迟5时， F407 (168MHz主频） GPIO模拟，实测 SCK 周期 = 480ns (大约2M)
;;;132    	*/
;;;133    	for (i = 0; i < 5; i++);
000002  e000              B        |L7.6|
                  |L7.4|
000004  1c40              ADDS     r0,r0,#1
                  |L7.6|
000006  2805              CMP      r0,#5
000008  d3fc              BCC      |L7.4|
;;;134    #else
;;;135    	/*
;;;136    		不添加延迟语句， F407 (168MHz主频） GPIO模拟，实测 SCK 周期 = 200ns (大约5M)
;;;137    	*/
;;;138    #endif
;;;139    }
00000a  4770              BX       lr
;;;140    
                          ENDP


                          AREA ||i.bsp_spiRead0||, CODE, READONLY, ALIGN=2

                  bsp_spiRead0 PROC
;;;195    */
;;;196    uint8_t bsp_spiRead0(void)
000000  b570              PUSH     {r4-r6,lr}
;;;197    {
;;;198    #ifdef SOFT_SPI		/* 软件SPI */
;;;199    	uint8_t i;
;;;200    	uint8_t read = 0;
000002  2400              MOVS     r4,#0
;;;201    
;;;202    	for (i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e018              B        |L8.58|
                  |L8.8|
;;;203    	{
;;;204    		read = read<<1;
000008  0660              LSLS     r0,r4,#25
00000a  0e04              LSRS     r4,r0,#24
;;;205    
;;;206    		if (MISO_IS_HIGH())
00000c  f44f7180          MOV      r1,#0x100
000010  480c              LDR      r0,|L8.68|
000012  f7fffffe          BL       GPIO_ReadInputDataBit
000016  2801              CMP      r0,#1
000018  d101              BNE      |L8.30|
;;;207    		{
;;;208    			read++;
00001a  1c60              ADDS     r0,r4,#1
00001c  b2c4              UXTB     r4,r0
                  |L8.30|
;;;209    		}
;;;210    		SCK_1();
00001e  2180              MOVS     r1,#0x80
000020  4808              LDR      r0,|L8.68|
000022  f7fffffe          BL       GPIO_SetBits
;;;211    		bsp_spiDelay();
000026  f7fffffe          BL       bsp_spiDelay
;;;212    		SCK_0();
00002a  2180              MOVS     r1,#0x80
00002c  4805              LDR      r0,|L8.68|
00002e  f7fffffe          BL       GPIO_ResetBits
;;;213    		bsp_spiDelay();
000032  f7fffffe          BL       bsp_spiDelay
000036  1c68              ADDS     r0,r5,#1              ;202
000038  b2c5              UXTB     r5,r0                 ;202
                  |L8.58|
00003a  2d08              CMP      r5,#8                 ;202
00003c  dbe4              BLT      |L8.8|
;;;214    	}
;;;215    	return read;
00003e  4620              MOV      r0,r4
;;;216    #endif
;;;217    
;;;218    #ifdef HARD_SPI		/* 硬件SPI */
;;;219    	uint8_t read;
;;;220    
;;;221    	/* 等待发送缓冲区空 */
;;;222    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
;;;223    
;;;224    	/* 发送一个字节 */
;;;225    	SPI_I2S_SendData(SPI1, 0);
;;;226    
;;;227    	/* 等待数据接收完毕 */
;;;228    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
;;;229    
;;;230    	/* 读取接收到的数据 */
;;;231    	read = SPI_I2S_ReceiveData(SPI1);
;;;232    
;;;233    	/* 返回读到的数据 */
;;;234    	return read;
;;;235    #endif
;;;236    }
000040  bd70              POP      {r4-r6,pc}
;;;237    
                          ENDP

000042  0000              DCW      0x0000
                  |L8.68|
                          DCD      0x40020400

                          AREA ||i.bsp_spiRead1||, CODE, READONLY, ALIGN=2

                  bsp_spiRead1 PROC
;;;299    */
;;;300    uint8_t bsp_spiRead1(void)
000000  b570              PUSH     {r4-r6,lr}
;;;301    {
;;;302    #ifdef SOFT_SPI		/* 软件SPI */
;;;303    	uint8_t i;
;;;304    	uint8_t read = 0;
000002  2400              MOVS     r4,#0
;;;305    
;;;306    	for (i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e018              B        |L9.58|
                  |L9.8|
;;;307    	{
;;;308    		SCK_0();
000008  2180              MOVS     r1,#0x80
00000a  480e              LDR      r0,|L9.68|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;309    		bsp_spiDelay();
000010  f7fffffe          BL       bsp_spiDelay
;;;310    		read = read << 1;
000014  0660              LSLS     r0,r4,#25
000016  0e04              LSRS     r4,r0,#24
;;;311    		if (MISO_IS_HIGH())
000018  f44f7180          MOV      r1,#0x100
00001c  4809              LDR      r0,|L9.68|
00001e  f7fffffe          BL       GPIO_ReadInputDataBit
000022  2801              CMP      r0,#1
000024  d101              BNE      |L9.42|
;;;312    		{
;;;313    			read++;
000026  1c60              ADDS     r0,r4,#1
000028  b2c4              UXTB     r4,r0
                  |L9.42|
;;;314    		}
;;;315    		SCK_1();
00002a  2180              MOVS     r1,#0x80
00002c  4805              LDR      r0,|L9.68|
00002e  f7fffffe          BL       GPIO_SetBits
;;;316    		bsp_spiDelay();
000032  f7fffffe          BL       bsp_spiDelay
000036  1c68              ADDS     r0,r5,#1              ;306
000038  b2c5              UXTB     r5,r0                 ;306
                  |L9.58|
00003a  2d08              CMP      r5,#8                 ;306
00003c  dbe4              BLT      |L9.8|
;;;317    	}
;;;318    	return read;
00003e  4620              MOV      r0,r4
;;;319    #endif
;;;320    
;;;321    #ifdef HARD_SPI		/* 硬件SPI */
;;;322    	uint8_t read;
;;;323    
;;;324    	/* 等待发送缓冲区空 */
;;;325    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
;;;326    
;;;327    	/* 发送一个字节 */
;;;328    	SPI_I2S_SendData(SPI1, 0);
;;;329    
;;;330    	/* 等待数据接收完毕 */
;;;331    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
;;;332    
;;;333    	/* 读取接收到的数据 */
;;;334    	read = SPI_I2S_ReceiveData(SPI1);
;;;335    
;;;336    	/* 返回读到的数据 */
;;;337    	return read;
;;;338    #endif
;;;339    }
000040  bd70              POP      {r4-r6,pc}
;;;340    
                          ENDP

000042  0000              DCW      0x0000
                  |L9.68|
                          DCD      0x40020400

                          AREA ||i.bsp_spiWrite0||, CODE, READONLY, ALIGN=2

                  bsp_spiWrite0 PROC
;;;148    */
;;;149    void bsp_spiWrite0(uint8_t _ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;150    {
000002  4604              MOV      r4,r0
;;;151    #ifdef SOFT_SPI		/* 软件SPI */
;;;152    	uint8_t i;
;;;153    
;;;154    	for(i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e01b              B        |L10.64|
                  |L10.8|
;;;155    	{
;;;156    		if (_ucByte & 0x80)
000008  f0040080          AND      r0,r4,#0x80
00000c  b120              CBZ      r0,|L10.24|
;;;157    		{
;;;158    			MOSI_1();
00000e  2120              MOVS     r1,#0x20
000010  480e              LDR      r0,|L10.76|
000012  f7fffffe          BL       GPIO_SetBits
000016  e003              B        |L10.32|
                  |L10.24|
;;;159    		}
;;;160    		else
;;;161    		{
;;;162    			MOSI_0();
000018  2120              MOVS     r1,#0x20
00001a  480c              LDR      r0,|L10.76|
00001c  f7fffffe          BL       GPIO_ResetBits
                  |L10.32|
;;;163    		}
;;;164    		bsp_spiDelay();
000020  f7fffffe          BL       bsp_spiDelay
;;;165    		SCK_1();
000024  2180              MOVS     r1,#0x80
000026  4809              LDR      r0,|L10.76|
000028  f7fffffe          BL       GPIO_SetBits
;;;166    		_ucByte <<= 1;
00002c  0660              LSLS     r0,r4,#25
00002e  0e04              LSRS     r4,r0,#24
;;;167    		bsp_spiDelay();
000030  f7fffffe          BL       bsp_spiDelay
;;;168    		SCK_0();
000034  2180              MOVS     r1,#0x80
000036  4805              LDR      r0,|L10.76|
000038  f7fffffe          BL       GPIO_ResetBits
00003c  1c68              ADDS     r0,r5,#1              ;154
00003e  b2c5              UXTB     r5,r0                 ;154
                  |L10.64|
000040  2d08              CMP      r5,#8                 ;154
000042  dbe1              BLT      |L10.8|
;;;169    	}
;;;170    	bsp_spiDelay();
000044  f7fffffe          BL       bsp_spiDelay
;;;171    #endif
;;;172    
;;;173    #ifdef HARD_SPI		/* 硬件SPI */
;;;174    	/* 等待发送缓冲区空 */
;;;175    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
;;;176    
;;;177    	/* 发送一个字节 */
;;;178    	SPI_I2S_SendData(SPI1, _ucByte);
;;;179    
;;;180    	/* 等待数据接收完毕 */
;;;181    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
;;;182    
;;;183    	/* 读取接收到的数据 */
;;;184    	SPI_I2S_ReceiveData(SPI1);
;;;185    #endif
;;;186    }
000048  bd70              POP      {r4-r6,pc}
;;;187    
                          ENDP

00004a  0000              DCW      0x0000
                  |L10.76|
                          DCD      0x40020400

                          AREA ||i.bsp_spiWrite1||, CODE, READONLY, ALIGN=2

                  bsp_spiWrite1 PROC
;;;245    */
;;;246    void bsp_spiWrite1(uint8_t _ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;247    {
000002  4604              MOV      r4,r0
;;;248    #ifdef SOFT_SPI		/* 软件SPI */
;;;249    	uint8_t i;
;;;250    
;;;251    	for(i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e01b              B        |L11.64|
                  |L11.8|
;;;252    	{
;;;253    		if (_ucByte & 0x80)
000008  f0040080          AND      r0,r4,#0x80
00000c  b120              CBZ      r0,|L11.24|
;;;254    		{
;;;255    			MOSI_1();
00000e  2120              MOVS     r1,#0x20
000010  480d              LDR      r0,|L11.72|
000012  f7fffffe          BL       GPIO_SetBits
000016  e003              B        |L11.32|
                  |L11.24|
;;;256    		}
;;;257    		else
;;;258    		{
;;;259    			MOSI_0();
000018  2120              MOVS     r1,#0x20
00001a  480b              LDR      r0,|L11.72|
00001c  f7fffffe          BL       GPIO_ResetBits
                  |L11.32|
;;;260    		}
;;;261    		SCK_0();
000020  2180              MOVS     r1,#0x80
000022  4809              LDR      r0,|L11.72|
000024  f7fffffe          BL       GPIO_ResetBits
;;;262    		_ucByte <<= 1;
000028  0660              LSLS     r0,r4,#25
00002a  0e04              LSRS     r4,r0,#24
;;;263    		bsp_spiDelay();
00002c  f7fffffe          BL       bsp_spiDelay
;;;264    		SCK_1();				/* SCK上升沿采集数据, SCK空闲时为高电平 */
000030  2180              MOVS     r1,#0x80
000032  4805              LDR      r0,|L11.72|
000034  f7fffffe          BL       GPIO_SetBits
;;;265    		bsp_spiDelay();
000038  f7fffffe          BL       bsp_spiDelay
00003c  1c68              ADDS     r0,r5,#1              ;251
00003e  b2c5              UXTB     r5,r0                 ;251
                  |L11.64|
000040  2d08              CMP      r5,#8                 ;251
000042  dbe1              BLT      |L11.8|
;;;266    	}
;;;267    #endif
;;;268    
;;;269    #ifdef HARD_SPI		/* 硬件SPI */
;;;270    	/* 等待发送缓冲区空 */
;;;271    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
;;;272    
;;;273    	/* 发送一个字节 */
;;;274    	SPI_I2S_SendData(SPI1, _ucByte);
;;;275    
;;;276    	/* 等待数据接收完毕 */
;;;277    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
;;;278    
;;;279    	/* 读取接收到的数据 */
;;;280    	SPI_I2S_ReceiveData(SPI1);
;;;281    #endif
;;;282    }
000044  bd70              POP      {r4-r6,pc}
;;;283    
                          ENDP

000046  0000              DCW      0x0000
                  |L11.72|
                          DCD      0x40020400

                          AREA ||.data||, DATA, ALIGN=0

                  g_spi_busy
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_spi_bus.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_bus_c_c88bcf96____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_spi_bus_c_c88bcf96____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_bus_c_c88bcf96____REVSH|
#line 144
|__asm___13_bsp_spi_bus_c_c88bcf96____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
