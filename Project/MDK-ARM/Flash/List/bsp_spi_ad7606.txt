; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_spi_ad7606.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_ad7606.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -D__MICROLIB -D__UVISION_VERSION=525 -D_RTE_ -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX --omf_browse=.\flash\obj\bsp_spi_ad7606.crf ..\..\User\bsp_stm32f4xx\src\bsp_spi_ad7606.c]
                          THUMB

                          AREA ||i.AD7606_CfgSpiHard||, CODE, READONLY, ALIGN=2

                  AD7606_CfgSpiHard PROC
;;;136    */
;;;137    void AD7606_CfgSpiHard(void)
000000  b500              PUSH     {lr}
;;;138    {
000002  b085              SUB      sp,sp,#0x14
;;;139    	SPI_InitTypeDef  SPI_InitStructure;
;;;140    
;;;141    	/* 配置SPI硬件参数 */
;;;142    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;	/* 数据方向：2线全双工 */
000004  2000              MOVS     r0,#0
000006  f8ad0000          STRH     r0,[sp,#0]
;;;143    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		/* STM32的SPI工作模式 ：主机模式 */
00000a  f44f7082          MOV      r0,#0x104
00000e  f8ad0002          STRH     r0,[sp,#2]
;;;144    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	/* 数据位长度 ： 8位 */
000012  2000              MOVS     r0,#0
000014  f8ad0004          STRH     r0,[sp,#4]
;;;145    	/* SPI_CPOL和SPI_CPHA结合使用决定时钟和数据采样点的相位关系、
;;;146    	   本例配置: 总线空闲是高电平,第2个边沿（上升沿采样数据)
;;;147    	*/
;;;148    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;			/* 时钟上升沿采样数据 */
000018  2002              MOVS     r0,#2
00001a  f8ad0006          STRH     r0,[sp,#6]
;;;149    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		/* 时钟的第2个边沿采样数据 */
00001e  2001              MOVS     r0,#1
000020  f8ad0008          STRH     r0,[sp,#8]
;;;150    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			/* 片选控制方式：软件控制 */
000024  0240              LSLS     r0,r0,#9
000026  f8ad000a          STRH     r0,[sp,#0xa]
;;;151    
;;;152    	/* 设置波特率预分频系数 SPI_BaudRatePrescaler_64 实测SCK周期 800ns ，12.5MHz */
;;;153    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
00002a  2028              MOVS     r0,#0x28
00002c  f8ad000c          STRH     r0,[sp,#0xc]
;;;154    
;;;155    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	/* 数据位传输次序：高位先传 */
000030  2000              MOVS     r0,#0
000032  f8ad000e          STRH     r0,[sp,#0xe]
;;;156    	SPI_InitStructure.SPI_CRCPolynomial = 7;			/* CRC多项式寄存器，复位后为7。本例程不用 */
000036  2007              MOVS     r0,#7
000038  f8ad0010          STRH     r0,[sp,#0x10]
;;;157    	SPI_Init(SPI1, &SPI_InitStructure);
00003c  4669              MOV      r1,sp
00003e  4804              LDR      r0,|L1.80|
000040  f7fffffe          BL       SPI_Init
;;;158    
;;;159    	SPI_Cmd(SPI1, ENABLE);				/* 使能SPI  */
000044  2101              MOVS     r1,#1
000046  4802              LDR      r0,|L1.80|
000048  f7fffffe          BL       SPI_Cmd
;;;160    }
00004c  b005              ADD      sp,sp,#0x14
00004e  bd00              POP      {pc}
;;;161    
                          ENDP

                  |L1.80|
                          DCD      0x40013000

                          AREA ||i.AD7606_ConfigGPIO||, CODE, READONLY, ALIGN=2

                  AD7606_ConfigGPIO PROC
;;;93     */
;;;94     static void AD7606_ConfigGPIO(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;95     {
;;;96     	GPIO_InitTypeDef GPIO_InitStructure;
;;;97     
;;;98     	/* 打开GPIO时钟 */
;;;99     	RCC_AHB1PeriphClockCmd(RCC_CS | RCC_RANGE | RCC_BUSY | RCC_RESET | RCC_CONVST, ENABLE);
000002  2101              MOVS     r1,#1
000004  2017              MOVS     r0,#0x17
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;100    
;;;101    	/* 配置几个推完输出IO */
;;;102    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00000a  2001              MOVS     r0,#1
00000c  f88d0004          STRB     r0,[sp,#4]
;;;103    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000010  2000              MOVS     r0,#0
000012  f88d0006          STRB     r0,[sp,#6]
;;;104    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
000016  f88d0007          STRB     r0,[sp,#7]
;;;105    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
00001a  2003              MOVS     r0,#3
00001c  f88d0005          STRB     r0,[sp,#5]
;;;106    
;;;107    	GPIO_InitStructure.GPIO_Pin = PIN_RESET;
000020  2010              MOVS     r0,#0x10
000022  9000              STR      r0,[sp,#0]
;;;108    	GPIO_Init(PORT_RESET, &GPIO_InitStructure);
000024  4669              MOV      r1,sp
000026  4813              LDR      r0,|L2.116|
000028  f7fffffe          BL       GPIO_Init
;;;109    
;;;110    	GPIO_InitStructure.GPIO_Pin = PIN_CONVST;
00002c  2080              MOVS     r0,#0x80
00002e  9000              STR      r0,[sp,#0]
;;;111    	GPIO_Init(PORT_CONVST, &GPIO_InitStructure);
000030  4669              MOV      r1,sp
000032  4811              LDR      r0,|L2.120|
000034  f7fffffe          BL       GPIO_Init
;;;112    	
;;;113    	GPIO_InitStructure.GPIO_Pin = PIN_RANGE;
000038  f44f7080          MOV      r0,#0x100
00003c  9000              STR      r0,[sp,#0]
;;;114    	GPIO_Init(PORT_RANGE, &GPIO_InitStructure);
00003e  4669              MOV      r1,sp
000040  480e              LDR      r0,|L2.124|
000042  f7fffffe          BL       GPIO_Init
;;;115    	
;;;116    	GPIO_InitStructure.GPIO_Pin = PIN_CS;
000046  2040              MOVS     r0,#0x40
000048  9000              STR      r0,[sp,#0]
;;;117    	GPIO_Init(PORT_CS, &GPIO_InitStructure);
00004a  4669              MOV      r1,sp
00004c  480c              LDR      r0,|L2.128|
00004e  f7fffffe          BL       GPIO_Init
;;;118    
;;;119    	/* 配置GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */
;;;120    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* 设为输入口 */
000052  2000              MOVS     r0,#0
000054  f88d0004          STRB     r0,[sp,#4]
;;;121    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000058  f88d0006          STRB     r0,[sp,#6]
;;;122    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 无需上下拉电阻 */
00005c  f88d0007          STRB     r0,[sp,#7]
;;;123    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO口最大速度 */
000060  2002              MOVS     r0,#2
000062  f88d0005          STRB     r0,[sp,#5]
;;;124    
;;;125    	GPIO_InitStructure.GPIO_Pin = PIN_BUSY;
000066  2010              MOVS     r0,#0x10
000068  9000              STR      r0,[sp,#0]
;;;126    	GPIO_Init(PORT_BUSY, &GPIO_InitStructure);
00006a  4669              MOV      r1,sp
00006c  4803              LDR      r0,|L2.124|
00006e  f7fffffe          BL       GPIO_Init
;;;127    }
000072  bd1c              POP      {r2-r4,pc}
;;;128    
                          ENDP

                  |L2.116|
                          DCD      0x40021000
                  |L2.120|
                          DCD      0x40020800
                  |L2.124|
                          DCD      0x40020000
                  |L2.128|
                          DCD      0x40020400

                          AREA ||i.AD7606_ReadAdc||, CODE, READONLY, ALIGN=2

                  AD7606_ReadAdc PROC
;;;323    */
;;;324    int16_t AD7606_ReadAdc(uint8_t _ch)
000000  4601              MOV      r1,r0
;;;325    {
;;;326    	int16_t sAdc;
;;;327    	
;;;328    	DISABLE_INT();	
000002  2001              MOVS     r0,#1
000004  f3808810          MSR      PRIMASK,r0
000008  bf00              NOP      
;;;329    	sAdc = s_adc_now[_ch];
00000a  4804              LDR      r0,|L3.28|
00000c  f9302011          LDRSH    r2,[r0,r1,LSL #1]
;;;330    	ENABLE_INT();
000010  2000              MOVS     r0,#0
000012  f3808810          MSR      PRIMASK,r0
000016  bf00              NOP      
;;;331    
;;;332    	return sAdc;
000018  4610              MOV      r0,r2
;;;333    }
00001a  4770              BX       lr
;;;334    
                          ENDP

                  |L3.28|
                          DCD      s_adc_now

                          AREA ||i.AD7606_Reset||, CODE, READONLY, ALIGN=2

                  AD7606_Reset PROC
;;;246    */
;;;247    void AD7606_Reset(void)
000000  b510              PUSH     {r4,lr}
;;;248    {
;;;249    	/* CS  SCLK拉高 */
;;;250    #ifdef SOFT_SPI
;;;251    		AD_CS_1();
000002  2140              MOVS     r1,#0x40
000004  480d              LDR      r0,|L4.60|
000006  f7fffffe          BL       GPIO_SetBits
;;;252    		//SCK_1();
;;;253    #endif
;;;254    
;;;255     	/* AD7606是高电平复位，要求最小脉宽50ns */
;;;256    	AD_RESET_LOW();
00000a  2110              MOVS     r1,#0x10
00000c  480c              LDR      r0,|L4.64|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;257    	
;;;258    	AD_RESET_HIGH();
000012  2110              MOVS     r1,#0x10
000014  480a              LDR      r0,|L4.64|
000016  f7fffffe          BL       GPIO_SetBits
;;;259    	AD_RESET_HIGH();
00001a  2110              MOVS     r1,#0x10
00001c  4808              LDR      r0,|L4.64|
00001e  f7fffffe          BL       GPIO_SetBits
;;;260    	AD_RESET_HIGH();
000022  2110              MOVS     r1,#0x10
000024  4806              LDR      r0,|L4.64|
000026  f7fffffe          BL       GPIO_SetBits
;;;261    	AD_RESET_HIGH();
00002a  2110              MOVS     r1,#0x10
00002c  4804              LDR      r0,|L4.64|
00002e  f7fffffe          BL       GPIO_SetBits
;;;262    	
;;;263    	AD_RESET_LOW();
000032  2110              MOVS     r1,#0x10
000034  4802              LDR      r0,|L4.64|
000036  f7fffffe          BL       GPIO_ResetBits
;;;264    }
00003a  bd10              POP      {r4,pc}
;;;265    /*
                          ENDP

                  |L4.60|
                          DCD      0x40020400
                  |L4.64|
                          DCD      0x40021000

                          AREA ||i.AD7606_Scan||, CODE, READONLY, ALIGN=2

                  AD7606_Scan PROC
;;;290    */
;;;291    void AD7606_Scan(void) 		/* 此函数代码按照时序编写 */
000000  b510              PUSH     {r4,lr}
;;;292    {
;;;293    	uint8_t i;			
;;;294    
;;;295    	/* BUSY = 0 时.ad7606处于空闲状态ad转换结束 */	
;;;296    	if (BUSY_IS_LOW())	   
000002  2110              MOVS     r1,#0x10
000004  4819              LDR      r0,|L5.108|
000006  f7fffffe          BL       GPIO_ReadInputDataBit
00000a  bb70              CBNZ     r0,|L5.106|
;;;297        {
;;;298    			bsp_DelayMS(1);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       bsp_DelayMS
;;;299    			if (BUSY_IS_LOW())
000012  2110              MOVS     r1,#0x10
000014  4815              LDR      r0,|L5.108|
000016  f7fffffe          BL       GPIO_ReadInputDataBit
00001a  bb30              CBNZ     r0,|L5.106|
;;;300    			{
;;;301    				while(GPIO_ReadInputDataBit(PORT_CS, PIN_CS))
00001c  e003              B        |L5.38|
                  |L5.30|
;;;302    					AD_CS_0(); /* SPI片选 = 0 */
00001e  2140              MOVS     r1,#0x40
000020  4813              LDR      r0,|L5.112|
000022  f7fffffe          BL       GPIO_ResetBits
                  |L5.38|
000026  2140              MOVS     r1,#0x40              ;301
000028  4811              LDR      r0,|L5.112|
00002a  f7fffffe          BL       GPIO_ReadInputDataBit
00002e  2800              CMP      r0,#0                 ;301
000030  d1f5              BNE      |L5.30|
;;;303    				
;;;304    				for (i = 0; i < CH_NUM; i++)
000032  2400              MOVS     r4,#0
000034  e011              B        |L5.90|
                  |L5.54|
;;;305    				{
;;;306    					s_adc_now[i] = bsp_spiRead1();
000036  f7fffffe          BL       bsp_spiRead1
00003a  490e              LDR      r1,|L5.116|
00003c  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;307    					
;;;308    					s_adc_now[i] = s_adc_now[i] * 256 + bsp_spiRead1(); /* 读数据 */	
000040  f7fffffe          BL       bsp_spiRead1
000044  490b              LDR      r1,|L5.116|
000046  f8111014          LDRB     r1,[r1,r4,LSL #1]
00004a  eb002001          ADD      r0,r0,r1,LSL #8
00004e  b200              SXTH     r0,r0
000050  4908              LDR      r1,|L5.116|
000052  f8210014          STRH     r0,[r1,r4,LSL #1]
000056  1c60              ADDS     r0,r4,#1              ;304
000058  b2c4              UXTB     r4,r0                 ;304
                  |L5.90|
00005a  2c08              CMP      r4,#8                 ;304
00005c  dbeb              BLT      |L5.54|
;;;309    				}
;;;310    				AD_CS_1(); /* SPI片选 = 1 */
00005e  2140              MOVS     r1,#0x40
000060  4803              LDR      r0,|L5.112|
000062  f7fffffe          BL       GPIO_SetBits
;;;311    				AD7606_StartConv();	/* 给开始信号 */	
000066  f7fffffe          BL       AD7606_StartConv
                  |L5.106|
;;;312    			}
;;;313    	}
;;;314    }	  
00006a  bd10              POP      {r4,pc}
;;;315    
                          ENDP

                  |L5.108|
                          DCD      0x40020000
                  |L5.112|
                          DCD      0x40020400
                  |L5.116|
                          DCD      s_adc_now

                          AREA ||i.AD7606_SetInputRange||, CODE, READONLY, ALIGN=2

                  AD7606_SetInputRange PROC
;;;226    */
;;;227    void AD7606_SetInputRange(uint8_t _ucRange)
000000  b510              PUSH     {r4,lr}
;;;228    {
000002  4604              MOV      r4,r0
;;;229    	if (_ucRange == 0)
000004  b92c              CBNZ     r4,|L6.18|
;;;230    	{
;;;231    		AD_RANGE_5V();	/* 设置为正负5V */
000006  f44f7180          MOV      r1,#0x100
00000a  4805              LDR      r0,|L6.32|
00000c  f7fffffe          BL       GPIO_ResetBits
000010  e004              B        |L6.28|
                  |L6.18|
;;;232    	}
;;;233    	else
;;;234    	{
;;;235    		AD_RANGE_10V();	/* 设置为正负10V */
000012  f44f7180          MOV      r1,#0x100
000016  4802              LDR      r0,|L6.32|
000018  f7fffffe          BL       GPIO_SetBits
                  |L6.28|
;;;236    	}
;;;237    }
00001c  bd10              POP      {r4,pc}
;;;238    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      0x40020000

                          AREA ||i.AD7606_StartConv||, CODE, READONLY, ALIGN=2

                  AD7606_StartConv PROC
;;;272    */
;;;273    void AD7606_StartConv(void)
000000  b510              PUSH     {r4,lr}
;;;274    {
;;;275    	/* 上升沿开始转换，低电平持续时间至少25ns  */
;;;276    	AD_CONVST_LOW();
000002  2180              MOVS     r1,#0x80
000004  4807              LDR      r0,|L7.36|
000006  f7fffffe          BL       GPIO_ResetBits
;;;277    	AD_CONVST_LOW();
00000a  2180              MOVS     r1,#0x80
00000c  4805              LDR      r0,|L7.36|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;278    	AD_CONVST_LOW();	/* 连续执行2次，低电平约50ns */
000012  2180              MOVS     r1,#0x80
000014  4803              LDR      r0,|L7.36|
000016  f7fffffe          BL       GPIO_ResetBits
;;;279    	
;;;280    	AD_CONVST_HIGH();
00001a  2180              MOVS     r1,#0x80
00001c  4801              LDR      r0,|L7.36|
00001e  f7fffffe          BL       GPIO_SetBits
;;;281    }
000022  bd10              POP      {r4,pc}
;;;282    
                          ENDP

                  |L7.36|
                          DCD      0x40020800

                          AREA ||i.bsp_spi_InitAD7606||, CODE, READONLY, ALIGN=2

                  bsp_spi_InitAD7606 PROC
;;;68     */
;;;69     void bsp_spi_InitAD7606(void)
000000  b510              PUSH     {r4,lr}
;;;70     {
;;;71     	AD7606_ConfigGPIO();		/* 配置GPIO */
000002  f7fffffe          BL       AD7606_ConfigGPIO
;;;72     	
;;;73     #ifdef HARD_SPI
;;;74     	AD7606_CfgSpiHard();
;;;75     #endif
;;;76     	
;;;77     	AD7606_SetInputRange(g_tAD7606.Range);	/* 设置采样量程 */
000006  4905              LDR      r1,|L8.28|
000008  7808              LDRB     r0,[r1,#0]  ; g_tAD7606
00000a  f7fffffe          BL       AD7606_SetInputRange
;;;78     
;;;79     	/* 设置过采样模式 */
;;;80     	//ad7606_SetOS(0);
;;;81     	AD7606_Reset();				/* 硬件复位复AD7606 */
00000e  f7fffffe          BL       AD7606_Reset
;;;82     	
;;;83     	AD_CONVST_HIGH();			/* CONVST脚设置为高电平 */	
000012  2180              MOVS     r1,#0x80
000014  4802              LDR      r0,|L8.32|
000016  f7fffffe          BL       GPIO_SetBits
;;;84     }
00001a  bd10              POP      {r4,pc}
;;;85     
                          ENDP

                  |L8.28|
                          DCD      g_tAD7606
                  |L8.32|
                          DCD      0x40020800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  s_adc_now
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  g_tAD7606
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_spi_ad7606.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_bsp_spi_ad7606_c_d0061c5a____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_bsp_spi_ad7606_c_d0061c5a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_bsp_spi_ad7606_c_d0061c5a____REVSH|
#line 144
|__asm___16_bsp_spi_ad7606_c_d0061c5a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
